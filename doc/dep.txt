
//继承
dag{
    Camera -> FilamentAPI
    BufferObject -> FilamentAPI
    ColorGrading -> FilamentAPI
    DebugRegistry -> FilamentAPI
    Fence -> FilamentAPI
    IndexBuffer -> FilamentAPI
    IndirectLight -> FilamentAPI
    LightManager -> FilamentAPI
    Material -> FilamentAPI
    MaterialInstance -> FilamentAPI
    MorphTargetBuffer -> FilamentAPI
    RenderableManager -> FilamentAPI
    Renderer -> FilamentAPI
    RenderTarget -> FilamentAPI
    Scene -> FilamentAPI
    SkinningBuffer -> FilamentAPI
    Skybox -> FilamentAPI
    Stream -> FilamentAPI
    SwapChain -> FilamentAPI
    Texture -> FilamentAPI
    TransformManager -> FilamentAPI
    VertexBuffer -> FilamentAPI
    View -> FilamentAPI
    CameraManager -> FilamentAPI
}

// has a builder
dag{
    BufferObject
    ColorGrading
    IndexBuffer
    IndirectLight
    LightManager
    Material
    MorphTargetBuffer
    RenderableManager
    RenderTarget
    SkinningBuffer
    Skybox
    Stream
    Texture
    VertexBuffer
    FrameGraph
}

//读源码的依赖顺序
dag{
    Skybox -> FilamentAPI //Skybox is a FilamentAPI
    Skybox -> Skybox::Builder //Skybox has a Builder
    Skybox::Builder -> BuilderBase<BuilderDetails>  // is

    FSkybox -> Skybox  //FSkybox is a Skybox
    FSkybox -> FMaterial 
    FSkybox -> FMaterialInstance
    FSkybox -> MaterialInstance 
    MaterialInstance -> TextureSampler
    Skybox -> Texture
    FSkybox -> RenderableManager  // FSkybox has a RenderableManager
    
    RenderableManager -> EntityInstance
    RenderableManager -> Entity
    RenderableManager -> FRenderableManager
    FRenderableManager -> SingleInstanceComponentManager
    SingleInstanceComponentManager -> EntityManager
    SingleInstanceComponentManager -> StructureOfArrays
    EntityManager -> Entity
    RenderableManager -> BuilderBase


-----------------------------------------------------------------------------------------
内存的分配
    builder::build
    Engine -> FEngine
    FEngine -> HeapAllocatorArena
    FEngine -> ResourceList
    HeapAllocatorArena -> HeapAllocator
    HeapAllocatorArena -> LockingPolicy
    HeapAllocatorArena -> TrackingPolicy
    HeapAllocator -> aligned_alloc
    aligned_alloc -> posix_memalign

    HeapAllocatorArena: 本质上就是一个支持调试，封装了一些功能， 比如直接构造出一个类，比如调试功能
    HeapAllocator: 默认就有内存对齐的分配器
}

---------------------------
如何理解内存对齐
Whereas malloc gives you a chunk of memory that could have any alignment (the only requirement is that it must be aligned for the largest primitive type that the implementation supports), posix_memalign gives you a chunk of memory that is guaranteed to have the requested alignment.

So the result of e.g. posix_memalign(&p, 32, 128) will be a 128-byte chunk of memory whose start address is guaranteed to be a multiple of 32.

This is useful for various low-level operations (such as using SSE instructions, or DMA), that require memory that obeys a particular alignment.

-----------------------------------------------------------------------------------------
Filament 是怎么实现ECS的？

Entity 是一个实体对象 ， 它的生命周期由 全局线程安全的单例对象 EntityManager 管理。
一个Entity 有一个ID, ID是 EntityManager 创建的时候分配的。 
EntityManager 可分配的Entity数量是有最大数量上限的，131072 (1 << 17)。
EntityManager 分配的Entity 数量超过了上限的时候 创建出来的Entity对象就是不合法的。
EntityManager 可以检查 Entity 对象的合法性。
EntityManager 的ID分配算法暂时没有看懂。
Entity的哈希值就是它的ID。
如果一个 Entity 没有回收，Entity就不可能再分配一个具有相同ID的Entity出来，所以如果两个Entity对象的ID,HASH相同，
那么其实这两个Entity对象 其实就是同一个Entity。一个Entity不能回收两次。

EntityInstance 和 Entity 什么关系？它们都是一个ID
StructureOfArrays 就是一个范型数据结构，可以表示任意的结构体里面有多个各种类型，但是大小相同的数组。
比如:
struct DemoDatas{
    int64_t         IDS[10];
    std::string     Names[10];
    float           Values[10];
} demoDatas;

就可以表示为
StructureOfArrays<int64_t, std::string, float> demoDatas(10);
并且可以使用迭代器访问。

SingleInstanceComponentManager

-------------------------------------------------
Filament 的API为什么要这么设计
Builder 构建者模式


 * FilamentAPI is used to define an API in filament.
 * It ensures the class defining the API can't be created, destroyed
 * or copied by the caller.
 所有的接口都继承 FilamentAPI ,这样就可以约束用户的行为

 FilamentAPI 的析构函数 是 protected not-virtual 的， 构造函数是protected 表明FilamentAPI 也就是说该类无法直接被构造和析构函数， 我们无法直接使用该类， 它只能作为基类。
 删除了 new操作符，用户无法new 它
 删除了拷贝和赋值，用户无法把它直接放到容器当中

